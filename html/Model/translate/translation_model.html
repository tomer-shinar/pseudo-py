<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>Model.translate.translation_model API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Model.translate.translation_model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from . import *
import os
import re
import autopep8
import ast

CODE_VERSION = 3

TAB = &#34; &#34; * 4


def count_on_start(string, sub_string):
    &#34;&#34;&#34;
    cont how many times substring appears in the begining of string
    :param string:
    :param sub_string:
    :return: the count
    &#34;&#34;&#34;
    count = 0
    while string.startswith(sub_string):
        count += 1
        string = string[len(sub_string):]
    return count


class TranslationModel(AbstractModel):
    &#34;&#34;&#34;
    the class that creates the translation from pseudo code to python code
    &#34;&#34;&#34;

    def __init__(self, g2g_model, pos_model, accuracy=None, version=None, path=&#34;saved-files&#34;):
        if not version:
            version = self.get_version(path)
        super().__init__(accuracy, (CODE_VERSION, version))
        self.g2g_model = g2g_model
        self.pos_model = pos_model

    def evaluate(self, input_data):
        &#34;&#34;&#34;
        this is the method that translates from pseudo code to python
        :param input_data: pseudo code text
        :return: list of tuples, each containing pseudo command and python translation
        &#34;&#34;&#34;
        commands = input_data.split(&#34;\n&#34;)
        translations = []
        for command in commands:
            translations.append([command, self.translate(command)])
            # using list of 2 items instead of tuple to allow use in js
        return translations

    def translate(self, command):
        &#34;&#34;&#34;
        translates one command to pseudo command(s)
        :param command: pseudo code string
        :return: python code
        &#34;&#34;&#34;
        original_command = command
        try:
            # remove tabs from the beginning of the first line and counts them
            tabs = count_on_start(command, TAB)
            command = command[tabs*4:]

            command_parts = self.split_by_strings(command)
            tokens = sum([self.tokenize(part) for part in command_parts], [])  # produce list of tokens
            if not tokens:
                # empty line
                return &#34;&#34;
            replacements = self.pos_model.evaluate(tokens)
            generic_pseudo = [replacements[t] if t in replacements.keys() else t for t in tokens]
            generic_python = self.g2g_model.evaluate(generic_pseudo)
            python_tokens = [replacements.inverse[t] if t in replacements.values() else t for t in generic_python]
            python_code = self.join_tokens(python_tokens)
            if not self.is_valid(python_code):
                raise TranslationException(&#34;wrong syntax for generated python code&#34;)
            return self.add_tabs(autopep8.fix_code(python_code), tabs)
        except TranslationException:
            return original_command

    @staticmethod
    def join_tokens(tokens):
        &#34;&#34;&#34;
        join the tokens to one string, adding space only after last char that is letter, digit or _
        :param tokens: list of tokens
        :return: string joining the tokens
        &#34;&#34;&#34;
        s = tokens[0]
        for token in tokens[1:]:
            if s[-1].isalpha() or s[-1].isdigit() or s[-1] == &#34;_&#34;:
                s += &#34; &#34;
            s += token
        return s

    @staticmethod
    def add_tabs(code, count):
        &#34;&#34;&#34;
        add the tabs to the beginning of each line
        :param code: the code without tabs
        :param count: the number of tabs
        :return: the new code
        &#34;&#34;&#34;
        return &#34;\n&#34;.join([TAB*count + line for line in code.split(&#39;\n&#39;)])

    @staticmethod
    def is_valid(python_code):
        &#34;&#34;&#34;
        check if the python code follows syntax rules
        :param python_code: python code
        :return: true if legal python code
        &#34;&#34;&#34;
        if_addition = &#34;if False:\n    pass\n&#34;  # if to add before else to make is parsable
        options = [python_code, TranslationModel.add_pass(python_code), if_addition + python_code,
                   if_addition + TranslationModel.add_pass(python_code)]
        for op in options:
            if TranslationModel.is_parsable(op):
                return True
        return False

    @staticmethod
    def is_parsable(code):
        &#34;&#34;&#34;
        check if the code can be parsed
        :param code: python code
        :return: true if can be parsed
        &#34;&#34;&#34;
        try:
            ast.parse(code)
            return True
        except SyntaxError:
            return False

    @staticmethod
    def add_pass(code):
        &#34;&#34;&#34;
        add pass to the last line of the code with the right amount of tabs
        :param code: the code need pass
        :return: new code
        &#34;&#34;&#34;
        lines = code.split(&#34;\n&#34;)
        tabs = count_on_start(lines[-1], TAB)
        lines.append(TAB * (tabs + 1) + &#34;pass&#34;)
        return &#34;\n&#34;.join(lines)

    @staticmethod
    def split_by_strings(command):
        &#34;&#34;&#34;
        split the command around all the strings in the command, meaning &#34;&#34;, &#39;&#39;
        :param command: pseudo code command
        :return: list of parts of the command and strings in it
        example: &#39;if x = \&#39;1\&#39; and y = &#34;2&#34; print &#34;hi&#34;&#39; =&gt; [&#39;if x = &#39;, &#39;\&#39;1\&#39;&#39;, &#39; and y = &#39;, &#39;&#34;2&#34;&#39;, &#39; print &#39;, &#39;&#34;hi&#34;&#39;]
        &#34;&#34;&#34;
        parts = []
        while command.find(&#39;&#34;&#39;) != -1 or command.find(&#34;&#39;&#34;) != -1:
            separator = &#39;&#34;&#39; if command.find(&#34;&#39;&#34;) == -1 else &#34;&#39;&#34; if command.find(&#39;&#34;&#39;) == -1 else min(&#39;&#34;&#39;, &#34;&#39;&#34;,
                                                                                                    key=command.find)
            # separator is the firs appears between &#34; and &#39;
            # add the part until the separator
            parts.append(command[:command.find(separator)])
            command = command[command.find(separator) + 1:]
            if command.find(separator) == -1:
                raise TranslationException(&#34;found opening {0} without closing one&#34;.format(separator))
            parts.append(separator + command[:command.find(separator) + 1])
            command = command[command.find(separator) + 1:]
        parts.append(command)
        return [p for p in parts if p != &#34;&#34;]

    @staticmethod
    def tokenize(sub_command):
        &#34;&#34;&#34;
        splits the sub command to tokens.
        each token is an independent unit in the command translation
        :param sub_command: part of command
        :return: list of tokens
        &#34;&#34;&#34;
        if sub_command.startswith(&#34;&#39;&#34;) or sub_command.startswith(&#39;&#34;&#39;):
            # string doesn&#39;t need to be tokenize
            return [sub_command]
        token_regex = &#39;|&#39;.join([
            r&#39;([^\W0-9]\w*)&#39;,  # name
            r&#39;(\d+\.?\d*)&#39;,  # number (without sign)
            r&#39;.&#39;  # any single char
        ])
        return [tok.group() for tok in re.finditer(token_regex, sub_command) if tok.group() != &#34; &#34;]

    def save(self, file_name):
        &#34;&#34;&#34;
        saves the model at file_name/version
        :param file_name: base directory
        &#34;&#34;&#34;
        path = os.path.join(file_name, *(str(v) for v in self.version))
        os.mkdir(path)
        self.g2g_model.save(os.path.join(path, &#34;g2g&#34;))
        self.pos_model.save(os.path.join(path, &#34;pos&#34;))

    @staticmethod
    def get_version(path):
        &#34;&#34;&#34;
        gets the version of this model
        :return: int representing the model version
        &#34;&#34;&#34;
        if not os.path.isdir(os.path.join(path, str(CODE_VERSION))):
            os.mkdir(os.path.join(path, str(CODE_VERSION)))
            f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
            f.write(&#34;1&#34;)
            f.close()
            return 0
        f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;r&#39;)
        version = int(f.read())
        f.close()
        f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
        f.write(str(version + 1))
        f.close()
        return version</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Model.translate.translation_model.count_on_start"><code class="name flex">
<span>def <span class="ident">count_on_start</span></span>(<span>string, sub_string)</span>
</code></dt>
<dd>
<div class="desc"><p>cont how many times substring appears in the begining of string
:param string:
:param sub_string:
:return: the count</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_on_start(string, sub_string):
    &#34;&#34;&#34;
    cont how many times substring appears in the begining of string
    :param string:
    :param sub_string:
    :return: the count
    &#34;&#34;&#34;
    count = 0
    while string.startswith(sub_string):
        count += 1
        string = string[len(sub_string):]
    return count</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Model.translate.translation_model.TranslationModel"><code class="flex name class">
<span>class <span class="ident">TranslationModel</span></span>
<span>(</span><span>g2g_model, pos_model, accuracy=None, version=None, path='saved-files')</span>
</code></dt>
<dd>
<div class="desc"><p>the class that creates the translation from pseudo code to python code</p>
<p>constructor
:param accuracy: the accuracy of the model
:param version: the version of the model, if it is a model from file and not new model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TranslationModel(AbstractModel):
    &#34;&#34;&#34;
    the class that creates the translation from pseudo code to python code
    &#34;&#34;&#34;

    def __init__(self, g2g_model, pos_model, accuracy=None, version=None, path=&#34;saved-files&#34;):
        if not version:
            version = self.get_version(path)
        super().__init__(accuracy, (CODE_VERSION, version))
        self.g2g_model = g2g_model
        self.pos_model = pos_model

    def evaluate(self, input_data):
        &#34;&#34;&#34;
        this is the method that translates from pseudo code to python
        :param input_data: pseudo code text
        :return: list of tuples, each containing pseudo command and python translation
        &#34;&#34;&#34;
        commands = input_data.split(&#34;\n&#34;)
        translations = []
        for command in commands:
            translations.append([command, self.translate(command)])
            # using list of 2 items instead of tuple to allow use in js
        return translations

    def translate(self, command):
        &#34;&#34;&#34;
        translates one command to pseudo command(s)
        :param command: pseudo code string
        :return: python code
        &#34;&#34;&#34;
        original_command = command
        try:
            # remove tabs from the beginning of the first line and counts them
            tabs = count_on_start(command, TAB)
            command = command[tabs*4:]

            command_parts = self.split_by_strings(command)
            tokens = sum([self.tokenize(part) for part in command_parts], [])  # produce list of tokens
            if not tokens:
                # empty line
                return &#34;&#34;
            replacements = self.pos_model.evaluate(tokens)
            generic_pseudo = [replacements[t] if t in replacements.keys() else t for t in tokens]
            generic_python = self.g2g_model.evaluate(generic_pseudo)
            python_tokens = [replacements.inverse[t] if t in replacements.values() else t for t in generic_python]
            python_code = self.join_tokens(python_tokens)
            if not self.is_valid(python_code):
                raise TranslationException(&#34;wrong syntax for generated python code&#34;)
            return self.add_tabs(autopep8.fix_code(python_code), tabs)
        except TranslationException:
            return original_command

    @staticmethod
    def join_tokens(tokens):
        &#34;&#34;&#34;
        join the tokens to one string, adding space only after last char that is letter, digit or _
        :param tokens: list of tokens
        :return: string joining the tokens
        &#34;&#34;&#34;
        s = tokens[0]
        for token in tokens[1:]:
            if s[-1].isalpha() or s[-1].isdigit() or s[-1] == &#34;_&#34;:
                s += &#34; &#34;
            s += token
        return s

    @staticmethod
    def add_tabs(code, count):
        &#34;&#34;&#34;
        add the tabs to the beginning of each line
        :param code: the code without tabs
        :param count: the number of tabs
        :return: the new code
        &#34;&#34;&#34;
        return &#34;\n&#34;.join([TAB*count + line for line in code.split(&#39;\n&#39;)])

    @staticmethod
    def is_valid(python_code):
        &#34;&#34;&#34;
        check if the python code follows syntax rules
        :param python_code: python code
        :return: true if legal python code
        &#34;&#34;&#34;
        if_addition = &#34;if False:\n    pass\n&#34;  # if to add before else to make is parsable
        options = [python_code, TranslationModel.add_pass(python_code), if_addition + python_code,
                   if_addition + TranslationModel.add_pass(python_code)]
        for op in options:
            if TranslationModel.is_parsable(op):
                return True
        return False

    @staticmethod
    def is_parsable(code):
        &#34;&#34;&#34;
        check if the code can be parsed
        :param code: python code
        :return: true if can be parsed
        &#34;&#34;&#34;
        try:
            ast.parse(code)
            return True
        except SyntaxError:
            return False

    @staticmethod
    def add_pass(code):
        &#34;&#34;&#34;
        add pass to the last line of the code with the right amount of tabs
        :param code: the code need pass
        :return: new code
        &#34;&#34;&#34;
        lines = code.split(&#34;\n&#34;)
        tabs = count_on_start(lines[-1], TAB)
        lines.append(TAB * (tabs + 1) + &#34;pass&#34;)
        return &#34;\n&#34;.join(lines)

    @staticmethod
    def split_by_strings(command):
        &#34;&#34;&#34;
        split the command around all the strings in the command, meaning &#34;&#34;, &#39;&#39;
        :param command: pseudo code command
        :return: list of parts of the command and strings in it
        example: &#39;if x = \&#39;1\&#39; and y = &#34;2&#34; print &#34;hi&#34;&#39; =&gt; [&#39;if x = &#39;, &#39;\&#39;1\&#39;&#39;, &#39; and y = &#39;, &#39;&#34;2&#34;&#39;, &#39; print &#39;, &#39;&#34;hi&#34;&#39;]
        &#34;&#34;&#34;
        parts = []
        while command.find(&#39;&#34;&#39;) != -1 or command.find(&#34;&#39;&#34;) != -1:
            separator = &#39;&#34;&#39; if command.find(&#34;&#39;&#34;) == -1 else &#34;&#39;&#34; if command.find(&#39;&#34;&#39;) == -1 else min(&#39;&#34;&#39;, &#34;&#39;&#34;,
                                                                                                    key=command.find)
            # separator is the firs appears between &#34; and &#39;
            # add the part until the separator
            parts.append(command[:command.find(separator)])
            command = command[command.find(separator) + 1:]
            if command.find(separator) == -1:
                raise TranslationException(&#34;found opening {0} without closing one&#34;.format(separator))
            parts.append(separator + command[:command.find(separator) + 1])
            command = command[command.find(separator) + 1:]
        parts.append(command)
        return [p for p in parts if p != &#34;&#34;]

    @staticmethod
    def tokenize(sub_command):
        &#34;&#34;&#34;
        splits the sub command to tokens.
        each token is an independent unit in the command translation
        :param sub_command: part of command
        :return: list of tokens
        &#34;&#34;&#34;
        if sub_command.startswith(&#34;&#39;&#34;) or sub_command.startswith(&#39;&#34;&#39;):
            # string doesn&#39;t need to be tokenize
            return [sub_command]
        token_regex = &#39;|&#39;.join([
            r&#39;([^\W0-9]\w*)&#39;,  # name
            r&#39;(\d+\.?\d*)&#39;,  # number (without sign)
            r&#39;.&#39;  # any single char
        ])
        return [tok.group() for tok in re.finditer(token_regex, sub_command) if tok.group() != &#34; &#34;]

    def save(self, file_name):
        &#34;&#34;&#34;
        saves the model at file_name/version
        :param file_name: base directory
        &#34;&#34;&#34;
        path = os.path.join(file_name, *(str(v) for v in self.version))
        os.mkdir(path)
        self.g2g_model.save(os.path.join(path, &#34;g2g&#34;))
        self.pos_model.save(os.path.join(path, &#34;pos&#34;))

    @staticmethod
    def get_version(path):
        &#34;&#34;&#34;
        gets the version of this model
        :return: int representing the model version
        &#34;&#34;&#34;
        if not os.path.isdir(os.path.join(path, str(CODE_VERSION))):
            os.mkdir(os.path.join(path, str(CODE_VERSION)))
            f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
            f.write(&#34;1&#34;)
            f.close()
            return 0
        f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;r&#39;)
        version = int(f.read())
        f.close()
        f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
        f.write(str(version + 1))
        f.close()
        return version</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Model.translate.abstract_model.AbstractModel" href="abstract_model.html#Model.translate.abstract_model.AbstractModel">AbstractModel</a></li>
<li>abc.ABC</li>
<li><a title="Model.logs.observable.Observable" href="../logs/observable.html#Model.logs.observable.Observable">Observable</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="Model.translate.translation_model.TranslationModel.add_pass"><code class="name flex">
<span>def <span class="ident">add_pass</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"><p>add pass to the last line of the code with the right amount of tabs
:param code: the code need pass
:return: new code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_pass(code):
    &#34;&#34;&#34;
    add pass to the last line of the code with the right amount of tabs
    :param code: the code need pass
    :return: new code
    &#34;&#34;&#34;
    lines = code.split(&#34;\n&#34;)
    tabs = count_on_start(lines[-1], TAB)
    lines.append(TAB * (tabs + 1) + &#34;pass&#34;)
    return &#34;\n&#34;.join(lines)</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.add_tabs"><code class="name flex">
<span>def <span class="ident">add_tabs</span></span>(<span>code, count)</span>
</code></dt>
<dd>
<div class="desc"><p>add the tabs to the beginning of each line
:param code: the code without tabs
:param count: the number of tabs
:return: the new code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_tabs(code, count):
    &#34;&#34;&#34;
    add the tabs to the beginning of each line
    :param code: the code without tabs
    :param count: the number of tabs
    :return: the new code
    &#34;&#34;&#34;
    return &#34;\n&#34;.join([TAB*count + line for line in code.split(&#39;\n&#39;)])</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.get_version"><code class="name flex">
<span>def <span class="ident">get_version</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>gets the version of this model
:return: int representing the model version</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_version(path):
    &#34;&#34;&#34;
    gets the version of this model
    :return: int representing the model version
    &#34;&#34;&#34;
    if not os.path.isdir(os.path.join(path, str(CODE_VERSION))):
        os.mkdir(os.path.join(path, str(CODE_VERSION)))
        f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
        f.write(&#34;1&#34;)
        f.close()
        return 0
    f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;r&#39;)
    version = int(f.read())
    f.close()
    f = open(os.path.join(path, str(CODE_VERSION), &#34;versions.txt&#34;), &#39;w&#39;)
    f.write(str(version + 1))
    f.close()
    return version</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.is_parsable"><code class="name flex">
<span>def <span class="ident">is_parsable</span></span>(<span>code)</span>
</code></dt>
<dd>
<div class="desc"><p>check if the code can be parsed
:param code: python code
:return: true if can be parsed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_parsable(code):
    &#34;&#34;&#34;
    check if the code can be parsed
    :param code: python code
    :return: true if can be parsed
    &#34;&#34;&#34;
    try:
        ast.parse(code)
        return True
    except SyntaxError:
        return False</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>python_code)</span>
</code></dt>
<dd>
<div class="desc"><p>check if the python code follows syntax rules
:param python_code: python code
:return: true if legal python code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_valid(python_code):
    &#34;&#34;&#34;
    check if the python code follows syntax rules
    :param python_code: python code
    :return: true if legal python code
    &#34;&#34;&#34;
    if_addition = &#34;if False:\n    pass\n&#34;  # if to add before else to make is parsable
    options = [python_code, TranslationModel.add_pass(python_code), if_addition + python_code,
               if_addition + TranslationModel.add_pass(python_code)]
    for op in options:
        if TranslationModel.is_parsable(op):
            return True
    return False</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.join_tokens"><code class="name flex">
<span>def <span class="ident">join_tokens</span></span>(<span>tokens)</span>
</code></dt>
<dd>
<div class="desc"><p>join the tokens to one string, adding space only after last char that is letter, digit or _
:param tokens: list of tokens
:return: string joining the tokens</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def join_tokens(tokens):
    &#34;&#34;&#34;
    join the tokens to one string, adding space only after last char that is letter, digit or _
    :param tokens: list of tokens
    :return: string joining the tokens
    &#34;&#34;&#34;
    s = tokens[0]
    for token in tokens[1:]:
        if s[-1].isalpha() or s[-1].isdigit() or s[-1] == &#34;_&#34;:
            s += &#34; &#34;
        s += token
    return s</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.split_by_strings"><code class="name flex">
<span>def <span class="ident">split_by_strings</span></span>(<span>command)</span>
</code></dt>
<dd>
<div class="desc"><p>split the command around all the strings in the command, meaning "", ''
:param command: pseudo code command
:return: list of parts of the command and strings in it
example: 'if x = '1' and y = "2" print "hi"' =&gt; ['if x = ', ''1'', ' and y = ', '"2"', ' print ', '"hi"']</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def split_by_strings(command):
    &#34;&#34;&#34;
    split the command around all the strings in the command, meaning &#34;&#34;, &#39;&#39;
    :param command: pseudo code command
    :return: list of parts of the command and strings in it
    example: &#39;if x = \&#39;1\&#39; and y = &#34;2&#34; print &#34;hi&#34;&#39; =&gt; [&#39;if x = &#39;, &#39;\&#39;1\&#39;&#39;, &#39; and y = &#39;, &#39;&#34;2&#34;&#39;, &#39; print &#39;, &#39;&#34;hi&#34;&#39;]
    &#34;&#34;&#34;
    parts = []
    while command.find(&#39;&#34;&#39;) != -1 or command.find(&#34;&#39;&#34;) != -1:
        separator = &#39;&#34;&#39; if command.find(&#34;&#39;&#34;) == -1 else &#34;&#39;&#34; if command.find(&#39;&#34;&#39;) == -1 else min(&#39;&#34;&#39;, &#34;&#39;&#34;,
                                                                                                key=command.find)
        # separator is the firs appears between &#34; and &#39;
        # add the part until the separator
        parts.append(command[:command.find(separator)])
        command = command[command.find(separator) + 1:]
        if command.find(separator) == -1:
            raise TranslationException(&#34;found opening {0} without closing one&#34;.format(separator))
        parts.append(separator + command[:command.find(separator) + 1])
        command = command[command.find(separator) + 1:]
    parts.append(command)
    return [p for p in parts if p != &#34;&#34;]</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.tokenize"><code class="name flex">
<span>def <span class="ident">tokenize</span></span>(<span>sub_command)</span>
</code></dt>
<dd>
<div class="desc"><p>splits the sub command to tokens.
each token is an independent unit in the command translation
:param sub_command: part of command
:return: list of tokens</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def tokenize(sub_command):
    &#34;&#34;&#34;
    splits the sub command to tokens.
    each token is an independent unit in the command translation
    :param sub_command: part of command
    :return: list of tokens
    &#34;&#34;&#34;
    if sub_command.startswith(&#34;&#39;&#34;) or sub_command.startswith(&#39;&#34;&#39;):
        # string doesn&#39;t need to be tokenize
        return [sub_command]
    token_regex = &#39;|&#39;.join([
        r&#39;([^\W0-9]\w*)&#39;,  # name
        r&#39;(\d+\.?\d*)&#39;,  # number (without sign)
        r&#39;.&#39;  # any single char
    ])
    return [tok.group() for tok in re.finditer(token_regex, sub_command) if tok.group() != &#34; &#34;]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Model.translate.translation_model.TranslationModel.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, input_data)</span>
</code></dt>
<dd>
<div class="desc"><p>this is the method that translates from pseudo code to python
:param input_data: pseudo code text
:return: list of tuples, each containing pseudo command and python translation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, input_data):
    &#34;&#34;&#34;
    this is the method that translates from pseudo code to python
    :param input_data: pseudo code text
    :return: list of tuples, each containing pseudo command and python translation
    &#34;&#34;&#34;
    commands = input_data.split(&#34;\n&#34;)
    translations = []
    for command in commands:
        translations.append([command, self.translate(command)])
        # using list of 2 items instead of tuple to allow use in js
    return translations</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name)</span>
</code></dt>
<dd>
<div class="desc"><p>saves the model at file_name/version
:param file_name: base directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file_name):
    &#34;&#34;&#34;
    saves the model at file_name/version
    :param file_name: base directory
    &#34;&#34;&#34;
    path = os.path.join(file_name, *(str(v) for v in self.version))
    os.mkdir(path)
    self.g2g_model.save(os.path.join(path, &#34;g2g&#34;))
    self.pos_model.save(os.path.join(path, &#34;pos&#34;))</code></pre>
</details>
</dd>
<dt id="Model.translate.translation_model.TranslationModel.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<div class="desc"><p>translates one command to pseudo command(s)
:param command: pseudo code string
:return: python code</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate(self, command):
    &#34;&#34;&#34;
    translates one command to pseudo command(s)
    :param command: pseudo code string
    :return: python code
    &#34;&#34;&#34;
    original_command = command
    try:
        # remove tabs from the beginning of the first line and counts them
        tabs = count_on_start(command, TAB)
        command = command[tabs*4:]

        command_parts = self.split_by_strings(command)
        tokens = sum([self.tokenize(part) for part in command_parts], [])  # produce list of tokens
        if not tokens:
            # empty line
            return &#34;&#34;
        replacements = self.pos_model.evaluate(tokens)
        generic_pseudo = [replacements[t] if t in replacements.keys() else t for t in tokens]
        generic_python = self.g2g_model.evaluate(generic_pseudo)
        python_tokens = [replacements.inverse[t] if t in replacements.values() else t for t in generic_python]
        python_code = self.join_tokens(python_tokens)
        if not self.is_valid(python_code):
            raise TranslationException(&#34;wrong syntax for generated python code&#34;)
        return self.add_tabs(autopep8.fix_code(python_code), tabs)
    except TranslationException:
        return original_command</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Model.translate.abstract_model.AbstractModel" href="abstract_model.html#Model.translate.abstract_model.AbstractModel">AbstractModel</a></b></code>:
<ul class="hlist">
<li><code><a title="Model.translate.abstract_model.AbstractModel.add_listener" href="../logs/observable.html#Model.logs.observable.Observable.add_listener">add_listener</a></code></li>
<li><code><a title="Model.translate.abstract_model.AbstractModel.notify" href="../logs/observable.html#Model.logs.observable.Observable.notify">notify</a></code></li>
<li><code><a title="Model.translate.abstract_model.AbstractModel.notify_creation" href="abstract_model.html#Model.translate.abstract_model.AbstractModel.notify_creation">notify_creation</a></code></li>
<li><code><a title="Model.translate.abstract_model.AbstractModel.notify_result" href="abstract_model.html#Model.translate.abstract_model.AbstractModel.notify_result">notify_result</a></code></li>
<li><code><a title="Model.translate.abstract_model.AbstractModel.remove_listener" href="../logs/observable.html#Model.logs.observable.Observable.remove_listener">remove_listener</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Model.translate" href="index.html">Model.translate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Model.translate.translation_model.count_on_start" href="#Model.translate.translation_model.count_on_start">count_on_start</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Model.translate.translation_model.TranslationModel" href="#Model.translate.translation_model.TranslationModel">TranslationModel</a></code></h4>
<ul class="two-column">
<li><code><a title="Model.translate.translation_model.TranslationModel.add_pass" href="#Model.translate.translation_model.TranslationModel.add_pass">add_pass</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.add_tabs" href="#Model.translate.translation_model.TranslationModel.add_tabs">add_tabs</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.evaluate" href="#Model.translate.translation_model.TranslationModel.evaluate">evaluate</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.get_version" href="#Model.translate.translation_model.TranslationModel.get_version">get_version</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.is_parsable" href="#Model.translate.translation_model.TranslationModel.is_parsable">is_parsable</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.is_valid" href="#Model.translate.translation_model.TranslationModel.is_valid">is_valid</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.join_tokens" href="#Model.translate.translation_model.TranslationModel.join_tokens">join_tokens</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.save" href="#Model.translate.translation_model.TranslationModel.save">save</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.split_by_strings" href="#Model.translate.translation_model.TranslationModel.split_by_strings">split_by_strings</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.tokenize" href="#Model.translate.translation_model.TranslationModel.tokenize">tokenize</a></code></li>
<li><code><a title="Model.translate.translation_model.TranslationModel.translate" href="#Model.translate.translation_model.TranslationModel.translate">translate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>